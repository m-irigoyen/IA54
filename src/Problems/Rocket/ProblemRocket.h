#ifndef PROBLEMROCKET_H_
#define PROBLEMROCKET_H_

#include <string>

#include "Problems/Problem.h"
#include "Problems/Rocket/ProblemRocket_Terrain.h"
#include "Utilities/FilePaths.h"

#define PROBLEMROCKET_GUI_ANGLE_OFFSET 90

using namespace std;

class ProblemRocket : public Problem
{
protected:
	// Terrain
	ProblemRocket_Terrain terrain;

	// Rocket current values
	vector<int> rocket_enginesPower;
	double rocket_angle;
	double rocket_hSpeed;
	double rocket_vSpeed;

	// Rocket position
	double rocket_x;
	double rocket_y;

	// Rocket status
	bool hasLanded;
	bool hasCrashed;
	bool hasGoneMissing;

	// Rocket control
	// Those values determine how fast the rocket can rotate, and how fast the engine's power can vary. Values < 0 mean the change is immediate.
	double rocketRotationRate;
	double engineChangeRate;

	// Agents influence
	double wave_amplitude_offset;
	double wave_amplitude_range;
	double wave_frequency_offset;
	double wave_frequency_range;

	double desiredRotationChange;	// desiredRotationChange is the offset to apply to the current rotation. desiredRotation is the value that the agent wants to reach 
	double desiredRotation;
	vector<int> desiredPowerChange;
	vector<int> desiredPower;

	// GUI stuff
	sf::Texture hud_rocketTexture;
	sf::Sprite hud_rocketSprite;
	sf::RectangleShape hud_engineFire;
	sf::Text hud_text;
	
	bool userControlled;	// When this is true, shuts down agent influences and allow the user to directly control the rocket

		// Helper functions
	// Terrain checking
	virtual bool correctLanding(double hSpeed, double vSpeed, double angle) = 0;	// Returns true if those value make a correct landing
	virtual void moveRocket(sf::Time elapsedTime, double hEnginesForce, double vEnginesForce);
	virtual void getThrustersForce(double& hForce, double& vForce) = 0;	// Compute the thrust generated by the engines with current angle and current enginePowers values
	virtual void rotateRocket() = 0;	// Rotate rocket. How, and how much, that's to the child class to decide

	// Event checking
	virtual void checkEvents(sf::RenderWindow* window);	// Checks for user input

	// returns the given angle constrained so 0 <= angle < 360
	double constrainAngle(double angle);	// Constrains given angle between 0 and 359 degrees

public:
	// Constructors
	ProblemRocket(float waveAmplLossPerSec = 0.0f, bool useAttenuation = false);

	// Running the problem
	// TO RUN THE PROBLEM : call getThrustersStrength to get the current force applied to the rocket. Then call moveRocket.
	virtual void run(sf::Time elapsedTime);			// Run the problem
	virtual void clean();
	virtual void resetRocket();	// Resets the rocket to its starting position, with starting hSpeed and vSpeed

	// Init
	virtual void init() = 0;
	virtual void initGraphics(std::vector<sf::Font>* fonts);

	// GUI
	virtual void draw(sf::RenderWindow* window, std::vector<sf::Font>* fonts);	// Draw the problem on the given window

	// Terrain
	virtual void loadTerrain(string path);
	virtual void generateTerrain(int width = -1, int height = -1);
	
	// Getters
	ProblemRocket_Terrain* getTerrain();
		// Rocket status
	bool getHasLanded();
	bool getHasCrashed();
	bool getHasGoneMissing();
	void getRocketPosition(double& rocketX, double& rocketY);
	void getRocketSpeed(double& rocketHSpeed, double& rocketVSpeed);
	double getRocketAngle();
	vector<int>* getRocketEnginesPower();

	// Agent influence
	void setDesiredPower(int engineNumber, int power);
	void setDesiredAngle(double angle);
	void setDesiredPowerChange(int engineNumber, int power);
	void setDesiredAngleChange(double angle);
};


#endif