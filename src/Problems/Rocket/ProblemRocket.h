#ifndef PROBLEMROCKET_H_
#define PROBLEMROCKET_H_

#include <string>

#include "Problems/Problem.h"
#include "Problems/Rocket/ProblemRocket_Terrain.h"
#include "Utilities/FilePaths.h"

// Rocket specs
#define PROBLEMROCKET_ROCKET_THRUST_BASE 8
#define PROBLEMROCKET_ROCKET_POWER_MAX 100

// GUI
#define PROBLEMROCKET_GUI_ANGLE_OFFSET 90
#define PROBLEMROCKET_GUI_SIZE_THRUSTER 0.5

using namespace std;

class ProblemRocket : public Problem
{
protected:
	// Terrain
	ProblemRocket_Terrain terrain;

	// Rocket current values
	vector<double> rocket_engineThrust;	// How much thrust does each engine generate
	vector<int> rocket_enginesPower;	// Percentage of power of the given engine, between 0 (no thrust) and 100 (max thrust)
	double rocket_angle;
	double rocket_hSpeed;
	double rocket_vSpeed;

	// Rocket position
	double rocket_x;
	double rocket_y;

	// Rocket status
	bool hasLanded;
	bool hasCrashed;
	bool hasGoneMissing;

	// Rocket control
	// Those values determine how fast the rocket can rotate, and how fast the engine's power can vary. Values < 0 mean the change is immediate.
	double rocket_rotationRate;
	int rocket_engineChangeRate;
	bool useGradualChange;	// If true, rotation and power are resolved using desiredRotationChange and desiredPowerChange. If false, they are resolved with desiredRotation and desiredPower. It's just a matter of choosing how the agents work : with hard values, or with offset changing.

	// Agents influence
	double wave_amplitude_offset;
	double wave_amplitude_range;
	double wave_frequency_offset;
	double wave_frequency_range;

	double desiredRotation;	// The influence towards which to go. If useGradualChange == true, that's treated as an offset to apply to the current value. Else, we set the rotation/power directly to the desired value
	vector<int> desiredPower;
	double rotationChange;	// The result of all influences on rotation change
	vector<int> powerChange;	// The result of all influences on power change

	// GUI stuff
	sf::Texture hud_rocketTexture;
	sf::Sprite hud_rocketSprite;
	sf::Text hud_text;
	
	bool userControlled;	// When this is true, shuts down agent influences and allow the user to directly control the rocket

		// Helper functions
	// Terrain checking
	virtual bool correctLanding(double hSpeed, double vSpeed, double angle);	// Returns true if those value make a correct landing
	virtual void moveRocket(sf::Time elapsedTime, double hEnginesForce, double vEnginesForce);
	virtual void getThrustForce(double& hForce, double& vForce) = 0;	// Compute the thrust generated by the engines with current angle and current enginePowers values

	// Event checking
	virtual void checkEvents(sf::RenderWindow* window);	// Checks for user input
	virtual bool handleEvent(sf::RenderWindow* window, sf::Event event);	// Returns true if event has been dealt with

	// Rocket control
	// returns the given angle constrained so 0 <= angle < 360
	virtual double constrainAngle(double angle);	// Constrains given angle between 0 and 359 degrees
	virtual double constrainAngleChange(double currentAngle, double desiredRotation);
	virtual int constrainPower(int power);
	virtual int constrainPowerChange(int currentPower, int desiredPowerChange);

	virtual void resolveRocketPowerChange() = 0;	// Based on the desired power and rotation, resolve what's happening
	virtual void resolveRocketAngleChange() = 0;

	virtual void resetDesiredChanges();

	// Agent influence
	virtual void resolveInfluences() = 0;
	

public:
	// Constructors
	ProblemRocket(float waveAmplLossPerSec = 0.0f, bool useAttenuation = false);

	// Running the problem
	// TO RUN THE PROBLEM : call getThrustersStrength to get the current force applied to the rocket. Then call moveRocket.
	virtual void run(sf::Time elapsedTime) = 0;			// Run the problem
	virtual void clean();
	virtual void resetRocket();	// Resets the rocket to its starting position, with starting hSpeed and vSpeed

	// Init
	virtual void init() = 0;
	virtual void initGraphics(std::vector<sf::Font>* fonts);
	virtual void setRocketRotationRate(double rocketRotationRate);
	virtual void setRocketengineChangeRate(int engineChangeRate);

	// GUI
	virtual void draw(sf::RenderWindow* window);	// Draw the problem on the given window

	// Terrain
	virtual void loadTerrain(string path);
	virtual void generateTerrain(int width = -1, int height = -1);
	
	// Getters
	ProblemRocket_Terrain* getTerrain();
		// Rocket data
	bool getHasLanded();
	bool getHasCrashed();
	bool getHasGoneMissing();
	void getRocketPosition(double& rocketX, double& rocketY);
	void getRocketSpeed(double& rocketHSpeed, double& rocketVSpeed);
	double getRocketAngle();
	vector<int>* getRocketEnginesPower();
	double getRocketDistanceToGround();
	double getRocketDistanceToLandingZoneCenter();
	double getLandingZoneSize();
	int getPowerMax();

		// Problem data
	double getWaveAmplitudeOffset();
	double getWaveAmplitudeRange();
	double getWaveFrequencyOffset();
	double getWaveFrequencyRange();

	// Rocket control
	void setPower(int engineNumber, int power);
	void setAngle(double angle);

	bool getUserControlled();

	// Agent influence
	void setDesiredPower(int engineNumber, int power);
	void setDesiredAngle(double angle);
};


#endif