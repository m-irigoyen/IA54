#ifndef PROBLEMROCKET_H_
#define PROBLEMROCKET_H_

#include <string>
#include <map>
#include "World/Vector.h"
#include "Problems/Problem.h"
#include "Problems/Rocket/ProblemRocket_Terrain.h"
#include "Problems/Rocket/ProblemRocket_Trajectory.h"
#include "Utilities/FilePaths.h"

// Rocket specs
#define PROBLEMROCKET_ROCKET_HITBOX 34.0f

#define PROBLEMROCKET_ROCKET_THRUST_BASE 8.0f

#define PROBLEMROCKET_ROCKET_POWER_MAX 100.0f
#define PROBLEMROCKET_ROCKET_POWER_BASE 50.0f
#define PROBLEMROCKET_ROCKET_ANGLE_TILT 45.0f

#define PROBLEMROCKET_ALTITUDE_OFFSET PROBLEMROCKET_ROCKET_HITBOX + 20.0f

#define PROBLEMROCKET_LANDING_MAXANGLE 5.0f
#define PROBLEMROCKET_LANDING_MAXHSPEED 20.0f
#define PROBLEMROCKET_LANDING_MAXVSPEED 40.0f
#define PROBLEMROCKET_CRUISE_MAXANGLE 45.0f
#define PROBLEMROCKET_CRUISE_MAXHSPEED 30.0f
#define PROBLEMROCKET_CRUISE_MAXVSPEED 50.0f

#define PROBLEMROCKET_DIRECTION_LZAPPROACH 0.5f

// GUI
#define PROBLEMROCKET_GUI_ANGLE_OFFSET 90.0f
#define PROBLEMROCKET_GUI_SIZE_THRUSTER 2.0f
#define PROBLEMROCKET_GUI_SCALE 0.5f

using namespace std;

class ProblemRocket : public Problem
{
protected:
	// Terrain
	ProblemRocket_Terrain terrain;
	ProblemRocket_Trajectory trajectories;

	// Problem status
	float problemSpeed;

	float problemMaxHSpeed;
	float problemMaxVSpeed;
	float problemMaxAngle;
	float problemPowerOffset;

	// Rocket current values
	vector<float> rocket_engineThrust;	// How much thrust does each engine generate
	vector<float> rocket_enginesPower;	// Percentage of power of the given engine, between 0 (no thrust) and 100 (max thrust)
	float rocket_angle;
	float rocket_hSpeed;
	float rocket_vSpeed;

	// Rocket position
	float rocket_x;
	float rocket_y;
	float desiredAltitude;

	// Rocket status
	bool hasLanded;
	bool hasCrashed;
	bool hasGoneMissing;

	// Rocket control
	// Those values determine how fast the rocket can rotate, and how fast the engine's power can vary. Values < 0 mean the change is immediate.
	float rocket_rotationRate;
	float rocket_engineChangeRate;
	bool useRelativeChange;	// If true, rotation and power are resolved using desiredRotationChange and desiredPowerChange. If false, they are resolved with desiredRotation and desiredPower. It's just a matter of choosing how the agents work : with hard values, or with offset changing.

	float desiredRotation;	// The influence towards which to go. If useGradualChange == true, that's treated as an offset to apply to the current value. Else, we set the rotation/power directly to the desired value
	vector<float> desiredPower;
	float rotationChange;	// The result of all influences on rotation change
	vector<float> powerChange;	// The result of all influences on power change

	// GUI stuff
	sf::Texture hud_rocketTexture;
	sf::Texture hud_explosionTexture;
	sf::Texture hud_radarTexture;
	sf::Sprite hud_rocketSprite;
	sf::Sprite hud_explosionSprite;
	sf::Sprite hud_radarSprite;

	sf::Text hud_text;
	bool drawHUD;
	
	bool userControlled;	// When this is true, shuts down agent influences and allow the user to directly control the rocket

	// Agents
	map<int, int> agentCount;

		// Helper functions
	// Terrain checking
	// Returns true if those value make a correct landing
	virtual bool correctLanding(float hSpeed, float vSpeed, float angle);
	virtual void moveRocket(sf::Time elapsedTime, float hEnginesForce, float vEnginesForce);
	virtual void getThrustForce(float& hForce, float& vForce) = 0;	// Compute the thrust generated by the engines with current angle and current enginePowers values

	// Event checking
	virtual void checkEvents(sf::RenderWindow* window);	// Checks for user input
	virtual bool handleEvent(sf::RenderWindow* window, sf::Event event);	// Returns true if event has been dealt with

		// Rocket control
	virtual void initUserControl(bool useControl) = 0;
	// returns the given angle constrained so 0 <= angle < 360
	virtual float constrainAngle(float angle);	// Constrains given angle between 0 and 359 degrees
	virtual float constrainAngleChange(float currentAngle, float desiredRotation);
	virtual float constrainPower(float power);
	virtual float constrainPowerChange(float currentPower, float desiredPowerChange);

	virtual void resolveRocketPowerChange() = 0;	// Based on the desired power and rotation, resolve what's happening
	virtual void resolveRocketAngleChange() = 0;

	virtual void resetDesiredChanges();

	virtual void setHasCrashed(bool crashed);
	virtual void setHasLanded(bool landed);
	virtual void setHasGoneMissing(bool goneMissing);


	// Agent influence
	virtual void resolveInfluences() = 0;
	
	// GUI
	void resetScale();

public:
	// Constructors
	ProblemRocket(float waveAmplLossPerSec = 0.0f, bool useAttenuation = false);

	// Running the problem
	// TO RUN THE PROBLEM : call getThrustersStrength to get the current force applied to the rocket. Then call moveRocket.
	virtual void run(sf::Time elapsedTime);			// Run the problem
	virtual void clean();
	virtual void resetRocket();	// Resets the rocket to its starting position, with starting hSpeed and vSpeed

	// Init
	virtual void init() = 0;
	virtual void initGraphics(std::vector<sf::Font>* fonts);
	virtual void setRocketRotationRate(float rocketRotationRate);
	virtual void setRocketengineChangeRate(float engineChangeRate);

	// GUI
	virtual void draw(sf::RenderWindow* window);	// Draw the problem on the given window

	// Terrain
	virtual void loadTerrain(string path);
	virtual void generateTerrain(int width = -1, int height = -1);
	
	// Getters
	ProblemRocket_Terrain* getTerrain();
		// Rocket data
	bool getHasLanded();
	bool getHasCrashed();
	bool getHasGoneMissing();
	void getRocketPosition(float& rocketX, float& rocketY);
	void getRocketSpeed(float& rocketHSpeed, float& rocketVSpeed);
	float getRocketAngle();
	vector<float>* getRocketEnginesPower();
	float getRocketDistanceToGround();
	float getRocketDistanceToLandingZoneCenter();
	float getLandingZoneSize();
	float getPowerMax();
	void getHighestPointBeforeLanding(float& pointX, float& pointY);
	void getSafeLandingSpecs(float& maxHSpeed, float& maxVSpeed, float& maxAngle);
	
	// Maximum speed and angle
	float getMaxHSpeed();
	float getMaxVSpeed();
	float getMaxAngle();
	void setMaxHSpeed(float maxHSpeed);
	void setMaxVSpeed(float maxVSpeed);
	void setMaxAngle(float maxAngle);


	// Rocket control
	void setPower(int engineNumber, float power);
	void setAngle(float angle);
	bool getUseRelativeChange();
	void setUseRelativeChange(bool relativeChange);
	
	float getDesiredAltitude();
	void setDesiredAltitude(float altitude);

	bool getUserControlled();

	// Agent influence
	void setDesiredPower(int engineNumber, float power);
	void setDesiredAngle(float angle);

	// Agent count
	void addedAgent(int agentType);
	void removedAgent(int agentType);

	map<int, int>& getAgentCount();

	// Returns true if those values make a correct landing
	bool checkCorrectLanding(float x, float y, float hSpeed, float vSpeed, float angle);

	float getPowerOffset();
};


#endif